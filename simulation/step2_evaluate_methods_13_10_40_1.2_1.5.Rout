
R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> #########################################################################
> #                                                                       #
> #                                                                       #
> #             Part II: Defferential Expression Analysis                 #
> #                                                                       #
> #                                                                       #
> #########################################################################
> # once simulated genes, we will do the Differential Expression Analysis
> # Here we will implement our method, plus the DESeq2 and the MAST analysis.
> 
> args = commandArgs(trailingOnly=TRUE)
> args
[1] "ncase=13"   "nctrl=10"   "ncell=40"   "r_mean=1.2" "r_var=1.5" 
> 
> if (length(args) < 5) {
+   message("no enough arguments, using default values")
+   r_mean   = 1.2     # The expected fold-changes in mean
+   r_var    = 1.5     # The expected fold-changes in variances
+   ncase    = 13      # case individuals
+   nctrl    = 10      # control individuals
+   ncell    = 360    # numbers of cells collected from each individuals.
+ } else{
+   for(i in 1:length(args)){
+     eval(parse(text=args[[i]]))
+   }
+ }
> 
> if(ncell == 0){
+   UNEQ_N_CELL = TRUE
+ }else{
+   UNEQ_N_CELL = FALSE
+ }
> 
> if(UNEQ_N_CELL){
+   config = sprintf("ncase_%d_nctrl_%d_unequal_n_cell", ncase, nctrl)
+ }else{
+   config = sprintf("ncase_%d_nctrl_%d_ncell_%d", ncase, nctrl, ncell)
+ }
> 
> config = sprintf("%s_fold_mean_%.1f_var_%.1f", config, r_mean, r_var)
> config
[1] "ncase_13_nctrl_10_ncell_40_fold_mean_1.2_var_1.5"
> 
> # ---------------------------------------------------------------
> # additional parameters
> # ---------------------------------------------------------------
> 
> nCore = 6      # number of cores for multi-core computation
> nall  = ncase + nctrl
> 
> # ---------------------------------------------------------------
> # initial setup
> # ---------------------------------------------------------------
> 
> library(MASS)
> library(emdbook)
> library(moments)
> library(MAST)
Loading required package: SingleCellExperiment
Loading required package: SummarizedExperiment
Loading required package: GenomicRanges
Loading required package: stats4
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    anyDuplicated, append, as.data.frame, basename, cbind, colnames,
    dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
    grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
    order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
    rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
    union, unique, unsplit, which, which.max, which.min

Loading required package: S4Vectors

Attaching package: ‘S4Vectors’

The following object is masked from ‘package:base’:

    expand.grid

Loading required package: IRanges
Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

Loading required package: DelayedArray
Loading required package: matrixStats

Attaching package: ‘matrixStats’

The following objects are masked from ‘package:Biobase’:

    anyMissing, rowMedians

Loading required package: BiocParallel

Attaching package: ‘DelayedArray’

The following objects are masked from ‘package:matrixStats’:

    colMaxs, colMins, colRanges, rowMaxs, rowMins, rowRanges

The following objects are masked from ‘package:base’:

    aperm, apply, rowsum

> library(lme4)
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:S4Vectors’:

    expand

> library(DESeq2)
> library(doParallel)
Loading required package: foreach
Loading required package: iterators
> library(foreach)
> library(doRNG)
Loading required package: rngtools
> library(MiRKAT)
> library(reticulate)
> library(transport)
> 
> library(data.table)

Attaching package: ‘data.table’

The following object is masked from ‘package:SummarizedExperiment’:

    shift

The following object is masked from ‘package:GenomicRanges’:

    shift

The following object is masked from ‘package:IRanges’:

    shift

The following objects are masked from ‘package:S4Vectors’:

    first, second

> library(pryr)
Registered S3 method overwritten by 'pryr':
  method      from
  print.bytes Rcpp

Attaching package: ‘pryr’

The following object is masked from ‘package:data.table’:

    address

> library(ggplot2)
> library(ggpubr)
Registered S3 methods overwritten by 'car':
  method                          from
  influence.merMod                lme4
  cooks.distance.influence.merMod lme4
  dfbeta.influence.merMod         lme4
  dfbetas.influence.merMod        lme4
> theme_set(theme_bw())
> 
> library(ideas)
> 
> registerDoParallel(cores=nCore)
> options(mc.cores=nCore)
> 
> # ---------------------------------------------------------------
> # load data
> # ---------------------------------------------------------------
> 
> sim_data     = readRDS(sprintf("data/sim_data_%s.rds", config))
> count_matrix = sim_data$count_matrix
> meta_cell    = sim_data$meta_cell
> meta_ind     = sim_data$meta_ind
> gene_index   = sim_data$gene_index
> 
> ls()
 [1] "args"         "config"       "count_matrix" "gene_index"   "i"           
 [6] "meta_cell"    "meta_ind"     "nall"         "ncase"        "ncell"       
[11] "nCore"        "nctrl"        "r_mean"       "r_var"        "sim_data"    
[16] "UNEQ_N_CELL" 
> EE_index   = gene_index$EE_index
> mean_index = gene_index$mean_index
> var_index  = gene_index$var_index
> 
> dim(count_matrix)
[1] 8000  920
> count_matrix[1:3,1:6]
      cell1 cell2 cell3 cell4 cell5 cell6
gene1     1     1     0     0     0     0
gene2     1     1     0     0     2     0
gene3     0     0     0     2     0     1
> 
> dim(meta_cell)
[1] 920   5
> meta_cell[1:2,]
      cell_id individual phenotype cell_rd      CDR
cell1   cell1       ind1         1    9738 0.439125
cell2   cell2       ind1         1    9605 0.444000
> 
> dim(meta_ind)
[1] 23  3
> meta_ind[1:2,]
     individual phenotype        RIN
ind1       ind1         1 -0.2784552
ind2       ind2         1 -0.7018300
> 
> rm(sim_data)
> gc()
           used  (Mb) gc trigger  (Mb) max used  (Mb)
Ncells  7149533 381.9   11345590 606.0  9204406 491.6
Vcells 19124544 146.0   30057288 229.4 19185607 146.4
> 
> # ---------------------------------------------------------------
> # 1. DESeq2 analysis 
> # ---------------------------------------------------------------
> # We calculate count_matrix_bulk by adding up raw counts of
> # all cells of an individual within a gene
> # ---------------------------------------------------------------
> 
> # individual level info
> u_ind = unique(meta_cell$individual)
> length(u_ind)
[1] 23
> u_ind[1:2]
[1] "ind1" "ind2"
> 
> count_matrix_bulk = matrix(nrow = nrow(count_matrix),
+                          ncol = length(u_ind))
> rownames(count_matrix_bulk) = rownames(count_matrix)
> colnames(count_matrix_bulk) = u_ind
> 
> for (i_ind in 1:length(u_ind)) {
+   cur_ind   = u_ind[i_ind]
+   cur_ind_m = count_matrix[, meta_cell$individual == cur_ind]
+   count_matrix_bulk[, i_ind] = rowSums(cur_ind_m, na.rm = TRUE)
+ }
> 
> dim(count_matrix_bulk)
[1] 8000   23
> count_matrix_bulk[1:3,1:5]
      ind1 ind2 ind3 ind4 ind5
gene1   18   15   21   21   21
gene2    6   17   22   12   45
gene3   10   10    7   14    6
> 
> meta_ind$phenotype = as.factor(meta_ind$phenotype)
> dim(meta_ind)
[1] 23  3
> meta_ind[1:2,]
     individual phenotype        RIN
ind1       ind1         1 -0.2784552
ind2       ind2         1 -0.7018300
> 
> # DESeq2 for all the genes
> dds = DESeqDataSetFromMatrix(countData = count_matrix_bulk,
+                              colData = meta_ind,
+                              design = ~ RIN + phenotype)
converting counts to integer mode
> 
> dds = DESeq(dds)
estimating size factors
estimating dispersions
gene-wise dispersion estimates
mean-dispersion relationship
final dispersion estimates
fitting model and testing
> nms = resultsNames(dds)
> nms
[1] "Intercept"        "RIN"              "phenotype_1_vs_0"
> 
> deseq2_pval = results(dds)$pvalue
> 
> rk = results(dds, name="RIN")
> deseq2_pval_RIN = rk$pvalue
> 
> summary(deseq2_pval)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.2179  0.4735  0.4786  0.7340  1.0000 
> summary(deseq2_pval_RIN)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.1587  0.4109  0.4382  0.7053  0.9999 
> table(deseq2_pval[EE_index] < 0.05)

FALSE  TRUE 
 5682   318 
> table(deseq2_pval[EE_index] < 0.05)/length(EE_index)

FALSE  TRUE 
0.947 0.053 
> 
> # ---------------------------------------------------------------
> # 2. IDEAS 
> # ---------------------------------------------------------------
> 
> var2test      = "phenotype"
> var2adjust    = "RIN"
> var2test_type = "binary"
> var_per_cell  = "cell_rd"
> 
> dist_list = list()
> 
> for(fit_method in c("zinb", "kde")){
+   for(d_metric in c("Was", "JSD")){
+     message(sprintf("fit_method: %s, d_metric: %s\n", fit_method, d_metric))
+     message(date())
+     
+     label = paste(fit_method, d_metric, sep="_")
+     fnm = sprintf("data/dist_%s_%s.rds", label, config)
+     if(file.exists(fnm)){
+       dist_list[[label]] = readRDS(fnm)
+     }else{
+       dist1 = ideas_dist(count_matrix, meta_cell, meta_ind, 
+                          var_per_cell, var2test, var2adjust, 
+                          var2test_type, d_metric = d_metric, 
+                          fit_method = fit_method)
+       dist_list[[label]] = dist1
+       saveRDS(dist1, fnm)
+     }
+   }
+ }
fit_method: zinb, d_metric: Was

Tue Jun  8 00:18:23 2021
fit_method: zinb, d_metric: JSD

Tue Jun  8 00:18:24 2021
fit_method: kde, d_metric: Was

Tue Jun  8 00:18:24 2021
fit_method: kde, d_metric: JSD

Tue Jun  8 00:18:25 2021
> 
> date()
[1] "Tue Jun  8 00:18:26 2021"
> 
> lapply(dist_list, dim)
$zinb_Was
[1] 8000   23   23

$zinb_JSD
[1] 8000   23   23

$kde_Was
[1] 8000   23   23

$kde_JSD
[1] 8000   23   23

> 
> dist_list$zinb_Was[1,1:3,1:3]
           ind1       ind2      ind3
ind1 0.00000000 0.04746146 0.1022751
ind2 0.04746146 0.00000000 0.1814359
ind3 0.10227509 0.18143586 0.0000000
> dist_list$zinb_JSD[1,1:3,1:3]
            ind1        ind2        ind3
ind1 0.000000000 0.002611212 0.002509889
ind2 0.002611212 0.000000000 0.010378317
ind3 0.002509889 0.010378317 0.000000000
> 
> # ---------------------------------------------------------------
> # STEP 2: pval calculation 
> # ---------------------------------------------------------------
> 
> n_gene = nrow(count_matrix)
> y = as.numeric(meta_ind$phenotype==1)
> 
> pval_KR = matrix(NA, nrow=n_gene, ncol=length(dist_list))
> rownames(pval_KR) = rownames(count_matrix)
> colnames(pval_KR) = paste("KR", names(dist_list), sep="_")
> 
> for(k in 1:length(dist_list)){
+   message(names(dist_list)[k])
+   message(date())
+   dist_k  = dist_list[[k]]
+   pval_KR[,k] = foreach(i_g = 1:dim(dist_k)[1], .combine = "c") %dopar% {
+     Di = dist_k[i_g,,]
+     if(any(is.na(Di))){
+       pval = NA 
+     }else{
+       Ki = D2K(Di)
+       m1 = MiRKAT(y = y, X = meta_ind$RIN, Ks = Ki, out_type = "D", 
+                   method = "permutation")
+       pval = m1$indivP
+     }
+     pval
+   }
+ }
zinb_Was
Tue Jun  8 00:18:26 2021
Error in pval_KR[, k] <- foreach(i_g = 1:dim(dist_k)[1], .combine = "c") %dopar%  : 
  number of items to replace is not a multiple of replacement length
Execution halted
