
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> #########################################################################
> #                                                                       #
> #                                                                       #
> #             Part II: Defferential Expression Analysis                 #
> #                                                                       #
> #                                                                       #
> #########################################################################
> # once simulated genes, we will do the Differential Expression Analysis
> # Here we will implement our method, plus the DESeq2 and the MAST analysis.
> 
> args = commandArgs(trailingOnly=TRUE)
> args
[1] "ncase=13"   "nctrl=10"   "ncell=0"    "r_mean=1.2" "r_var=1.5" 
> 
> if (length(args) < 5) {
+   message("no enough arguments, using default values")
+   r_mean   = 1.2     # The expected fold-changes in mean
+   r_var    = 1.5     # The expected fold-changes in variances
+   ncase    = 13      # case individuals
+   nctrl    = 10      # control individuals
+   ncell    = 360    # numbers of cells collected from each individuals.
+ } else{
+   for(i in 1:length(args)){
+     eval(parse(text=args[[i]]))
+   }
+ }
> 
> if(ncell == 0){
+   UNEQ_N_CELL = TRUE
+ }else{
+   UNEQ_N_CELL = FALSE
+ }
> 
> if(UNEQ_N_CELL){
+   config = sprintf("ncase_%d_nctrl_%d_unequal_n_cell", ncase, nctrl)
+ }else{
+   config = sprintf("ncase_%d_nctrl_%d_ncell_%d", ncase, nctrl, ncell)
+ }
> 
> config = sprintf("%s_fold_mean_%.1f_var_%.1f", config, r_mean, r_var)
> config
[1] "ncase_13_nctrl_10_unequal_n_cell_fold_mean_1.2_var_1.5"
> 
> # ---------------------------------------------------------------
> # additional parameters
> # ---------------------------------------------------------------
> 
> nCore = 6      # number of cores for multi-core computation
> nall  = ncase + nctrl
> 
> # ---------------------------------------------------------------
> # initial setup
> # ---------------------------------------------------------------
> 
> library(MASS)
> library(emdbook)
> library(moments)
> library(MAST)
Loading required package: SingleCellExperiment
Loading required package: SummarizedExperiment
Loading required package: GenomicRanges
Loading required package: stats4
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    anyDuplicated, append, as.data.frame, basename, cbind, colnames,
    dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
    grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
    order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
    rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
    union, unique, unsplit, which, which.max, which.min

Loading required package: S4Vectors

Attaching package: ‘S4Vectors’

The following object is masked from ‘package:base’:

    expand.grid

Loading required package: IRanges
Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

Loading required package: DelayedArray
Loading required package: matrixStats

Attaching package: ‘matrixStats’

The following objects are masked from ‘package:Biobase’:

    anyMissing, rowMedians

Loading required package: BiocParallel

Attaching package: ‘DelayedArray’

The following objects are masked from ‘package:matrixStats’:

    colMaxs, colMins, colRanges, rowMaxs, rowMins, rowRanges

The following objects are masked from ‘package:base’:

    aperm, apply, rowsum


Attaching package: ‘MAST’

The following object is masked from ‘package:stats’:

    filter

> library(lme4)
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:S4Vectors’:

    expand

> library(DESeq2)
> library(doParallel)
Loading required package: foreach
Loading required package: iterators
> library(foreach)
> library(doRNG)
Loading required package: rngtools
> library(MiRKAT)
> library(reticulate)
> library(transport)
> 
> library(data.table)

Attaching package: ‘data.table’

The following object is masked from ‘package:SummarizedExperiment’:

    shift

The following object is masked from ‘package:GenomicRanges’:

    shift

The following object is masked from ‘package:IRanges’:

    shift

The following objects are masked from ‘package:S4Vectors’:

    first, second

> library(pryr)
Registered S3 method overwritten by 'pryr':
  method      from
  print.bytes Rcpp

Attaching package: ‘pryr’

The following object is masked from ‘package:data.table’:

    address

> library(ggplot2)
> library(ggpubr)
Loading required package: magrittr
> theme_set(theme_bw())
> 
> library(ideas)
> 
> registerDoParallel(cores=nCore)
> options(mc.cores=nCore)
> 
> # ---------------------------------------------------------------
> # load data
> # ---------------------------------------------------------------
> 
> sim_data     = readRDS(sprintf("data/sim_data_%s.rds", config))
> count_matrix = sim_data$count_matrix
> meta_cell    = sim_data$meta_cell
> meta_ind     = sim_data$meta_ind
> gene_index   = sim_data$gene_index
> 
> ls()
 [1] "args"         "config"       "count_matrix" "gene_index"   "i"           
 [6] "meta_cell"    "meta_ind"     "nall"         "ncase"        "ncell"       
[11] "nCore"        "nctrl"        "r_mean"       "r_var"        "sim_data"    
[16] "UNEQ_N_CELL" 
> EE_index   = gene_index$EE_index
> mean_index = gene_index$mean_index
> var_index  = gene_index$var_index
> 
> dim(count_matrix)
[1] 8000 8626
> count_matrix[1:3,1:6]
      cell1 cell2 cell3 cell4 cell5 cell6
gene1     1     1     0     0     0     0
gene2     1     1     0     0     2     0
gene3     0     0     0     2     0     1
> 
> dim(meta_cell)
[1] 8626    5
> meta_cell[1:2,]
      cell_id individual phenotype cell_rd      CDR
cell1   cell1       ind1         1    9738 0.439125
cell2   cell2       ind1         1    9605 0.444000
> 
> dim(meta_ind)
[1] 23  3
> meta_ind[1:2,]
     individual phenotype        RIN
ind1       ind1         1 -0.2784552
ind2       ind2         1 -0.7018300
> 
> rm(sim_data)
> gc()
           used  (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb)
Ncells  6934555 370.4   12437792 664.3         NA  9014139 481.5
Vcells 80569316 614.7  118415368 903.5      32768 80629115 615.2
> 
> # ---------------------------------------------------------------
> # 1. DESeq2 analysis 
> # ---------------------------------------------------------------
> # We calculate count_matrix_bulk by adding up raw counts of
> # all cells of an individual within a gene
> # ---------------------------------------------------------------
> 
> # individual level info
> u_ind = unique(meta_cell$individual)
> length(u_ind)
[1] 23
> u_ind[1:2]
[1] "ind1" "ind2"
> 
> count_matrix_bulk = matrix(nrow = nrow(count_matrix),
+                          ncol = length(u_ind))
> rownames(count_matrix_bulk) = rownames(count_matrix)
> colnames(count_matrix_bulk) = u_ind
> 
> for (i_ind in 1:length(u_ind)) {
+   cur_ind   = u_ind[i_ind]
+   cur_ind_m = count_matrix[, meta_cell$individual == cur_ind]
+   count_matrix_bulk[, i_ind] = rowSums(cur_ind_m, na.rm = TRUE)
+ }
> 
> dim(count_matrix_bulk)
[1] 8000   23
> count_matrix_bulk[1:3,1:5]
      ind1 ind2 ind3 ind4 ind5
gene1   73  270  172   33  156
gene2   51  168  271   21  278
gene3   45  207   78   17   64
> 
> meta_ind$phenotype = as.factor(meta_ind$phenotype)
> dim(meta_ind)
[1] 23  3
> meta_ind[1:2,]
     individual phenotype        RIN
ind1       ind1         1 -0.2784552
ind2       ind2         1 -0.7018300
> 
> # DESeq2 for all the genes
> dds = DESeqDataSetFromMatrix(countData = count_matrix_bulk,
+                              colData = meta_ind,
+                              design = ~ RIN + phenotype)
converting counts to integer mode
> 
> dds = DESeq(dds)
estimating size factors
estimating dispersions
gene-wise dispersion estimates
mean-dispersion relationship
final dispersion estimates
fitting model and testing
> nms = resultsNames(dds)
> nms
[1] "Intercept"        "RIN"              "phenotype_1_vs_0"
> 
> deseq2_pval = results(dds)$pvalue
> 
> rk = results(dds, name="RIN")
> deseq2_pval_RIN = rk$pvalue
> 
> summary(deseq2_pval)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.1834  0.4519  0.4609  0.7277  1.0000 
> summary(deseq2_pval_RIN)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.1057  0.3486  0.3950  0.6574  0.9999 
> table(deseq2_pval[EE_index] < 0.05)

FALSE  TRUE 
 5604   396 
> table(deseq2_pval[EE_index] < 0.05)/length(EE_index)

FALSE  TRUE 
0.934 0.066 
> 
> # ---------------------------------------------------------------
> # 2. IDEAS 
> # ---------------------------------------------------------------
> 
> var2test      = "phenotype"
> var2adjust    = "RIN"
> var2test_type = "binary"
> var_per_cell  = "cell_rd"
> 
> dist_list = list()
> 
> for(fit_method in c("zinb", "kde")){
+   for(d_metric in c("Was", "JSD")){
+     message(sprintf("fit_method: %s, d_metric: %s\n", fit_method, d_metric))
+     message(date())
+     
+     label = paste(fit_method, d_metric, sep="_")
+     fnm = sprintf("data/dist_%s_%s.rds", label, config)
+     if(file.exists(fnm)){
+       dist_list[[label]] = readRDS(fnm)
+     }else{
+       dist1 = ideas_dist(count_matrix, meta_cell, meta_ind, 
+                          var_per_cell, var2test, var2adjust, 
+                          var2test_type, d_metric = d_metric, 
+                          fit_method = fit_method)
+       dist_list[[label]] = dist1
+       saveRDS(dist1, fnm)
+     }
+   }
+ }
fit_method: zinb, d_metric: Was

Tue Sep  8 12:44:15 2020
fit_method: zinb, d_metric: JSD

Tue Sep  8 12:44:15 2020
fit_method: kde, d_metric: Was

Tue Sep  8 12:44:15 2020
fit_method: kde, d_metric: JSD

Tue Sep  8 12:44:15 2020
> 
> date()
[1] "Tue Sep  8 12:44:15 2020"
> 
> lapply(dist_list, dim)
$zinb_Was
[1] 8000   23   23

$zinb_JSD
[1] 8000   23   23

$kde_Was
[1] 8000   23   23

$kde_JSD
[1] 8000   23   23

> 
> dist_list$zinb_Was[1,1:3,1:3]
           ind1       ind2       ind3
ind1 0.00000000 0.00983515 0.02349819
ind2 0.00983515 0.00000000 0.02364572
ind3 0.02349819 0.02364572 0.00000000
> dist_list$zinb_JSD[1,1:3,1:3]
             ind1         ind2         ind3
ind1 0.0000000000 0.0001181899 0.0002320240
ind2 0.0001181899 0.0000000000 0.0002467667
ind3 0.0002320240 0.0002467667 0.0000000000
> 
> # ---------------------------------------------------------------
> # STEP 2: pval calculation 
> # ---------------------------------------------------------------
> 
> n_gene = nrow(count_matrix)
> y = as.numeric(meta_ind$phenotype==1)
> 
> pval_KR = matrix(NA, nrow=n_gene, ncol=length(dist_list))
> rownames(pval_KR) = rownames(count_matrix)
> colnames(pval_KR) = paste("KR", names(dist_list), sep="_")
> 
> for(k in 1:length(dist_list)){
+   message(names(dist_list)[k])
+   message(date())
+   dist_k  = dist_list[[k]]
+   pval_KR[,k] = foreach(i_g = 1:dim(dist_k)[1], .combine = "c") %dopar% {
+     Di = dist_k[i_g,,]
+     if(any(is.na(Di))){
+       pval = NA 
+     }else{
+       Ki = D2K(Di)
+       m1 = MiRKAT(y = y, X = meta_ind$RIN, Ks = Ki, out_type = "D", 
+                   method = "permutation")
+       pval = m1$indivP
+     }
+     pval
+   }
+ }
zinb_Was
Tue Sep  8 12:44:15 2020
zinb_JSD
Tue Sep  8 12:45:17 2020
kde_Was
Tue Sep  8 12:46:24 2020
kde_JSD
Tue Sep  8 12:47:28 2020
> date()
[1] "Tue Sep  8 12:48:29 2020"
> 
> dim(pval_KR)
[1] 8000    4
> pval_KR[1:2,]
      KR_zinb_Was KR_zinb_JSD KR_kde_Was KR_kde_JSD
gene1       0.703       0.775      0.871      0.774
gene2       0.558       0.787      0.421      0.224
> 
> 
> n_perm = 999
> r.seed = 903
> 
> pval_PS = matrix(NA, nrow=n_gene, ncol=length(dist_list))
> rownames(pval_PS) = rownames(count_matrix)
> colnames(pval_PS) = names(dist_list)
> colnames(pval_PS) = paste("PS", names(dist_list), sep="_")
> 
> for(k in 1:length(dist_list)){
+   message(names(dist_list)[k])
+   message(date())
+   dist_k  = dist_list[[k]]
+   pval_PS[,k] = permanova(dist_k, meta_ind, var2test, var2adjust, 
+                           var2test_type, n_perm=n_perm, 
+                           r.seed=r.seed, residulize.x = FALSE)
+ }
zinb_Was
Tue Sep  8 12:48:29 2020
skip 56 gene(s) with NA in the dist_array

testing for 'phenotype', a binary variable

zinb_JSD
Tue Sep  8 12:51:53 2020
skip 56 gene(s) with NA in the dist_array

testing for 'phenotype', a binary variable

kde_Was
Tue Sep  8 12:55:53 2020
testing for 'phenotype', a binary variable

kde_JSD
Tue Sep  8 13:00:08 2020
testing for 'phenotype', a binary variable

> date()
[1] "Tue Sep  8 13:03:55 2020"
> 
> summary(pval_KR)
  KR_zinb_Was      KR_zinb_JSD       KR_kde_Was       KR_kde_JSD    
 Min.   :0.0010   Min.   :0.0010   Min.   :0.0010   Min.   :0.0010  
 1st Qu.:0.1750   1st Qu.:0.1520   1st Qu.:0.1630   1st Qu.:0.2150  
 Median :0.4210   Median :0.4030   Median :0.4180   Median :0.4750  
 Mean   :0.4429   Mean   :0.4295   Mean   :0.4404   Mean   :0.4809  
 3rd Qu.:0.7000   3rd Qu.:0.6850   3rd Qu.:0.6990   3rd Qu.:0.7470  
 Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  
 NA's   :56       NA's   :56                                        
> summary(pval_PS)
  PS_zinb_Was      PS_zinb_JSD       PS_kde_Was       PS_kde_JSD    
 Min.   :0.0010   Min.   :0.0010   Min.   :0.0010   Min.   :0.0010  
 1st Qu.:0.1660   1st Qu.:0.1470   1st Qu.:0.1570   1st Qu.:0.2130  
 Median :0.4135   Median :0.3970   Median :0.4080   Median :0.4690  
 Mean   :0.4378   Mean   :0.4248   Mean   :0.4354   Mean   :0.4785  
 3rd Qu.:0.6930   3rd Qu.:0.6790   3rd Qu.:0.6970   3rd Qu.:0.7420  
 Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  
 NA's   :56       NA's   :56                                        
> 
> round(cor(-log10(pval_KR), use="pair"),2)
            KR_zinb_Was KR_zinb_JSD KR_kde_Was KR_kde_JSD
KR_zinb_Was        1.00        0.91       0.91       0.62
KR_zinb_JSD        0.91        1.00       0.87       0.62
KR_kde_Was         0.91        0.87       1.00       0.66
KR_kde_JSD         0.62        0.62       0.66       1.00
> round(cor(-log10(pval_PS), use="pair"),2)
            PS_zinb_Was PS_zinb_JSD PS_kde_Was PS_kde_JSD
PS_zinb_Was        1.00        0.91       0.91       0.62
PS_zinb_JSD        0.91        1.00       0.87       0.62
PS_kde_Was         0.91        0.87       1.00       0.67
PS_kde_JSD         0.62        0.62       0.67       1.00
> 
> round(cor(-log10(pval_KR), -log10(pval_PS), use="pair"),2)
            PS_zinb_Was PS_zinb_JSD PS_kde_Was PS_kde_JSD
KR_zinb_Was        0.99        0.90       0.90       0.61
KR_zinb_JSD        0.90        0.99       0.87       0.62
KR_kde_Was         0.90        0.86       0.99       0.66
KR_kde_JSD         0.61        0.62       0.66       0.99
> 
> # ---------------------------------------------------------------
> # 3. MAST analysis 
> # ---------------------------------------------------------------
> #
> # the input of MAST analysis can be matrix or SingleCellAssay.
> #
> # input:
> # (1) the log-transformed expression count matrix,
> #     with each column represents a cell and each row represents a gene.
> # (2) the meta data, including cell and individual information.
> 
> # we get the p-values based on the Hurdle model ("H" model)
> # ---------------------------------------------------------------
> 
> rds = colSums(count_matrix)
> med_rds = median(rds)
> summary(rds)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   8921    9632    9916    9975   10239   14193 
> med_rds
[1] 9916
> 
> dim(count_matrix)
[1] 8000 8626
> count_matrix[1:3,1:6]
      cell1 cell2 cell3 cell4 cell5 cell6
gene1     1     1     0     0     0     0
gene2     1     1     0     0     2     0
gene3     0     0     0     2     0     1
> count_matrix = t(t(count_matrix)/rds)*med_rds
> dim(count_matrix)
[1] 8000 8626
> count_matrix[1:3,1:6]
         cell1    cell2 cell3    cell4    cell5    cell6
gene1 1.018279 1.032379     0 0.000000 0.000000 0.000000
gene2 1.018279 1.032379     0 0.000000 1.847415 0.000000
gene3 0.000000 0.000000     0 1.981021 0.000000 1.030234
> summary(colSums(count_matrix))
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   9916    9916    9916    9916    9916    9916 
> 
> count_matrix_log = log2(1 + count_matrix) #log transformed data
> 
> dim(count_matrix_log)
[1] 8000 8626
> count_matrix_log[1:3, 1:4]
         cell1    cell2 cell3    cell4
gene1 1.013126 1.023169     0 0.000000
gene2 1.013126 1.023169     0 0.000000
gene3 0.000000 0.000000     0 1.575806
> cell_id = colnames(count_matrix_log)   # get the cell id from the data
> gene_id = rownames(count_matrix_log)   # get the gene id from the data
> 
> diagnosis = as.character(meta_cell$phenotype) #
> diagnosis[diagnosis == 1] = "Case"
> diagnosis[diagnosis == 0] = "Control"
> 
> fData = data.frame(primerid = gene_id)
> cData = data.frame(wellKey  = cell_id)
> 
> sca = FromMatrix(count_matrix_log, cData, fData)
Assuming data assay in position 1, with name et is log-transformed.
> colData(sca)$cngeneson = as.numeric(meta_cell$CDR)
> colData(sca)$diagnosis = as.factor(diagnosis)
> colData(sca)$ind = as.factor(meta_cell$individual)
> colData(sca)$RIN = meta_ind$RIN[match(meta_cell$individual, 
+                                       meta_ind$individual)]
> 
> colData(sca)
DataFrame with 8626 rows and 5 columns
             wellKey cngeneson diagnosis      ind                RIN
         <character> <numeric>  <factor> <factor>          <numeric>
cell1          cell1  0.439125      Case     ind1 -0.278455206659536
cell2          cell2     0.444      Case     ind1 -0.278455206659536
cell3          cell3     0.438      Case     ind1 -0.278455206659536
cell4          cell4  0.440125      Case     ind1 -0.278455206659536
cell5          cell5  0.442125      Case     ind1 -0.278455206659536
...              ...       ...       ...      ...                ...
cell8622    cell8622      0.45   Control    ind23 -0.711802340635773
cell8623    cell8623     0.444   Control    ind23 -0.711802340635773
cell8624    cell8624  0.441125   Control    ind23 -0.711802340635773
cell8625    cell8625     0.458   Control    ind23 -0.711802340635773
cell8626    cell8626  0.430875   Control    ind23 -0.711802340635773
> 
> rm(count_matrix)
> rm(count_matrix_log)
> gc()
            used  (Mb) gc trigger   (Mb) limit (Mb)  max used   (Mb)
Ncells   7068953 377.6   12437792  664.3         NA  12437792  664.3
Vcells 100026503 763.2  395796975 3019.7      32768 410697014 3133.4
> gc()
            used  (Mb) gc trigger   (Mb) limit (Mb)  max used   (Mb)
Ncells   7068958 377.6   12437792  664.3         NA  12437792  664.3
Vcells 100026522 763.2  316637580 2415.8      32768 410697014 3133.4
> gc()
            used  (Mb) gc trigger   (Mb) limit (Mb)  max used   (Mb)
Ncells   7068958 377.6   12437792  664.3         NA  12437792  664.3
Vcells 100026522 763.2  316637580 2415.8      32768 410697014 3133.4
> 
> getOption("mc.cores")
[1] 6
> 
> date()
[1] "Tue Sep  8 13:04:06 2020"
> b0 = zlm(formula = ~ diagnosis + cngeneson + RIN, sca = sca, 
+          parallel = TRUE)

Done!
> date()
[1] "Tue Sep  8 13:10:31 2020"
> b1 = zlm(formula = ~ diagnosis + (1 | ind) + cngeneson + RIN, sca = sca, 
+          method = 'glmer', ebayes = FALSE, parallel = TRUE)
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular

Done!
Warning message:
In checkConv(attr(opt, "derivs"), opt$par, ctrl = control$checkConv,  :
  Model failed to converge with max|grad| = 0.001976 (tol = 0.001, component 1)
> date()
[1] "Tue Sep  8 14:25:07 2020"
> 
> b0
Fitted zlm on 8000 genes and 8626 cells.
 Using BayesGLMlike ~ diagnosis + cngeneson + RIN 
> b1
Fitted zlm on 8000 genes and 8626 cells.
 Using LMERlike ~ diagnosis + (1 | ind) + cngeneson + RIN 
> 
> date()
[1] "Tue Sep  8 14:25:07 2020"
> lrt0 = lrTest(b0, "diagnosis")
Refitting on reduced model...

Done!
> date()
[1] "Tue Sep  8 14:29:40 2020"
> lrt1 = lrTest(b1, "diagnosis")
Refitting on reduced model...
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular
boundary (singular) fit: see ?isSingular

Done!
> date()
[1] "Tue Sep  8 15:20:11 2020"
> 
> dim(lrt0)
[1] 8000    3    3
> lrt0[1,,]
         metric
test.type    lambda df Pr(>Chisq)
   cont   2.1314628  1  0.1443030
   disc   0.2713828  1  0.6024057
   hurdle 2.4028456  2  0.3007660
> 
> dim(lrt1)
[1] 8000    3    3
> lrt1[1,,]
         metric
test.type     lambda df Pr(>Chisq)
   cont   0.09182397  1  0.7618710
   disc   0.09786685  1  0.7544047
   hurdle 0.18969082  2  0.9095135
> 
> mast_pval_glm = apply(lrt0, 1, function(x){x[3,3]})
> length(mast_pval_glm)
[1] 8000
> mast_pval_glm[1:4]
       gene1        gene2        gene3        gene4 
3.007660e-01 2.561724e-06 7.142758e-01 4.150981e-20 
> 
> mast_pval_glmer = apply(lrt1, 1, function(x){x[3,3]})
> length(mast_pval_glmer)
[1] 8000
> mast_pval_glmer[1:4]
       gene1        gene2        gene3        gene4 
0.9095135252 0.9748741000 0.7883087070 0.0009596994 
> 
> # ---------------------------------------------------------------
> # check p-value
> # ---------------------------------------------------------------
> 
> idx_grp = list(meanDE=mean_index, varDE=var_index, EE=EE_index)
> 
> plot.hist <- function(pvals, idx_grp, label){
+   for(k in 1:length(idx_grp)){
+     idx  = idx_grp[[k]]
+     main = paste(label, names(idx_grp)[k], sep=", ")
+     hist(pvals[idx], main=main, xlab="p-value", breaks=50)
+   }
+ }
> 
> geneType = rep("EE", n_gene)
> geneType[mean_index] = "meanDE"
> geneType[var_index]  = "varDE"
> 
> df1 = data.frame(geneType, pval_KR, pval_PS, deseq2_pval, 
+                  mast_pval_glm, mast_pval_glmer)
> dim(df1)
[1] 8000   12
> df1[1:2,]
      geneType KR_zinb_Was KR_zinb_JSD KR_kde_Was KR_kde_JSD PS_zinb_Was
gene1       EE       0.703       0.775      0.871      0.774       0.691
gene2       EE       0.558       0.787      0.421      0.224       0.550
      PS_zinb_JSD PS_kde_Was PS_kde_JSD deseq2_pval mast_pval_glm
gene1       0.742      0.848      0.708   0.8556880  3.007660e-01
gene2       0.773      0.430      0.207   0.7624385  2.561724e-06
      mast_pval_glmer
gene1       0.9095135
gene2       0.9748741
> 
> 
> pdf(sprintf("figures/pvalue_hist_%s.pdf", config), 
+     width = 9, height = 9)
> par(mfrow = c(3, 3), mar=c(5,4,2,1), pty = "s", bty="n")
> for(k in 2:ncol(df1)){
+   plot.hist(df1[,k], idx_grp, names(df1)[k])
+ }
> dev.off()
null device 
          1 
> 
> # ---------------------------------------------------------------
> # save results
> # ---------------------------------------------------------------
> 
> 
> fun1 <- function(x, alpha){table(x<=alpha)/length(x)}
> apply(df1[,-1], 2, function(v){tapply(v, df1$geneType, fun1, alpha=0.05)})
$KR_zinb_Was
$KR_zinb_Was$EE

     FALSE       TRUE 
0.94366667 0.04983333 

$KR_zinb_Was$meanDE

FALSE  TRUE 
0.709 0.282 

$KR_zinb_Was$varDE

FALSE  TRUE 
0.777 0.215 


$KR_zinb_JSD
$KR_zinb_JSD$EE

     FALSE       TRUE 
0.94333333 0.05016667 

$KR_zinb_JSD$meanDE

FALSE  TRUE 
0.725 0.266 

$KR_zinb_JSD$varDE

FALSE  TRUE 
0.571 0.421 


$KR_kde_Was
$KR_kde_Was$EE

     FALSE       TRUE 
0.95216667 0.04783333 

$KR_kde_Was$meanDE

FALSE  TRUE 
0.683 0.317 

$KR_kde_Was$varDE

FALSE  TRUE 
0.685 0.315 


$KR_kde_JSD
$KR_kde_JSD$EE

 FALSE   TRUE 
0.9605 0.0395 

$KR_kde_JSD$meanDE

FALSE  TRUE 
0.823 0.177 

$KR_kde_JSD$varDE

FALSE  TRUE 
0.774 0.226 


$PS_zinb_Was
$PS_zinb_Was$EE

     FALSE       TRUE 
0.94233333 0.05116667 

$PS_zinb_Was$meanDE

FALSE  TRUE 
0.711 0.280 

$PS_zinb_Was$varDE

FALSE  TRUE 
0.777 0.215 


$PS_zinb_JSD
$PS_zinb_JSD$EE

     FALSE       TRUE 
0.94083333 0.05266667 

$PS_zinb_JSD$meanDE

FALSE  TRUE 
0.721 0.270 

$PS_zinb_JSD$varDE

FALSE  TRUE 
0.567 0.425 


$PS_kde_Was
$PS_kde_Was$EE

FALSE  TRUE 
0.949 0.051 

$PS_kde_Was$meanDE

FALSE  TRUE 
0.677 0.323 

$PS_kde_Was$varDE

FALSE  TRUE 
  0.7   0.3 


$PS_kde_JSD
$PS_kde_JSD$EE

     FALSE       TRUE 
0.96233333 0.03766667 

$PS_kde_JSD$meanDE

FALSE  TRUE 
0.823 0.177 

$PS_kde_JSD$varDE

FALSE  TRUE 
0.785 0.215 


$deseq2_pval
$deseq2_pval$EE

FALSE  TRUE 
0.934 0.066 

$deseq2_pval$meanDE

FALSE  TRUE 
0.598 0.402 

$deseq2_pval$varDE

FALSE  TRUE 
0.932 0.068 


$mast_pval_glm
$mast_pval_glm$EE

    FALSE      TRUE 
0.3803333 0.6196667 

$mast_pval_glm$meanDE

FALSE  TRUE 
0.116 0.884 

$mast_pval_glm$varDE

FALSE  TRUE 
0.002 0.998 


$mast_pval_glmer
$mast_pval_glmer$EE

    FALSE      TRUE 
0.9288333 0.0710000 

$mast_pval_glmer$meanDE

FALSE  TRUE 
0.635 0.365 

$mast_pval_glmer$varDE

FALSE  TRUE 
0.198 0.802 


> apply(df1[,-1], 2, function(v){tapply(v, df1$geneType, fun1, alpha=0.01)})
$KR_zinb_Was
$KR_zinb_Was$EE

     FALSE       TRUE 
0.98333333 0.01016667 

$KR_zinb_Was$meanDE

FALSE  TRUE 
0.855 0.136 

$KR_zinb_Was$varDE

FALSE  TRUE 
0.924 0.068 


$KR_zinb_JSD
$KR_zinb_JSD$EE

     FALSE       TRUE 
0.98266667 0.01083333 

$KR_zinb_JSD$meanDE

FALSE  TRUE 
0.856 0.135 

$KR_zinb_JSD$varDE

FALSE  TRUE 
0.763 0.229 


$KR_kde_Was
$KR_kde_Was$EE

      FALSE        TRUE 
0.990166667 0.009833333 

$KR_kde_Was$meanDE

FALSE  TRUE 
0.847 0.153 

$KR_kde_Was$varDE

FALSE  TRUE 
0.877 0.123 


$KR_kde_JSD
$KR_kde_JSD$EE

      FALSE        TRUE 
0.991833333 0.008166667 

$KR_kde_JSD$meanDE

FALSE  TRUE 
0.926 0.074 

$KR_kde_JSD$varDE

FALSE  TRUE 
0.904 0.096 


$PS_zinb_Was
$PS_zinb_Was$EE

     FALSE       TRUE 
0.98233333 0.01116667 

$PS_zinb_Was$meanDE

FALSE  TRUE 
0.854 0.137 

$PS_zinb_Was$varDE

FALSE  TRUE 
0.927 0.065 


$PS_zinb_JSD
$PS_zinb_JSD$EE

 FALSE   TRUE 
0.9810 0.0125 

$PS_zinb_JSD$meanDE

FALSE  TRUE 
0.852 0.139 

$PS_zinb_JSD$varDE

FALSE  TRUE 
0.754 0.238 


$PS_kde_Was
$PS_kde_Was$EE

      FALSE        TRUE 
0.990666667 0.009333333 

$PS_kde_Was$meanDE

FALSE  TRUE 
0.847 0.153 

$PS_kde_Was$varDE

FALSE  TRUE 
 0.86  0.14 


$PS_kde_JSD
$PS_kde_JSD$EE

      FALSE        TRUE 
0.992333333 0.007666667 

$PS_kde_JSD$meanDE

FALSE  TRUE 
0.931 0.069 

$PS_kde_JSD$varDE

FALSE  TRUE 
0.909 0.091 


$deseq2_pval
$deseq2_pval$EE

     FALSE       TRUE 
0.98366667 0.01633333 

$deseq2_pval$meanDE

FALSE  TRUE 
0.754 0.246 

$deseq2_pval$varDE

FALSE  TRUE 
0.985 0.015 


$mast_pval_glm
$mast_pval_glm$EE

    FALSE      TRUE 
0.4836667 0.5163333 

$mast_pval_glm$meanDE

FALSE  TRUE 
 0.17  0.83 

$mast_pval_glm$varDE

FALSE  TRUE 
0.006 0.994 


$mast_pval_glmer
$mast_pval_glmer$EE

    FALSE      TRUE 
0.9803333 0.0195000 

$mast_pval_glmer$meanDE

FALSE  TRUE 
0.792 0.208 

$mast_pval_glmer$varDE

FALSE  TRUE 
0.316 0.684 


> 
> write.table(df1, file=sprintf("results/pval_%s.txt", config), append=FALSE, 
+             quote=FALSE, sep="\t", row.names = FALSE, col.names = TRUE)
> 
> sessionInfo()
R version 3.6.2 (2019-12-12)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: macOS Catalina 10.15.6

Matrix products: default
BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] ideas_0.991                 ggpubr_0.2.5               
 [3] magrittr_1.5                ggplot2_3.3.1              
 [5] pryr_0.1.4                  data.table_1.12.8          
 [7] transport_0.12-2            reticulate_1.15            
 [9] MiRKAT_1.1.0                doRNG_1.8.2                
[11] rngtools_1.5                doParallel_1.0.15          
[13] iterators_1.0.12            foreach_1.4.7              
[15] DESeq2_1.24.0               lme4_1.1-21                
[17] Matrix_1.2-18               MAST_1.10.0                
[19] SingleCellExperiment_1.6.0  SummarizedExperiment_1.14.1
[21] DelayedArray_0.10.0         BiocParallel_1.18.1        
[23] matrixStats_0.55.0          Biobase_2.44.0             
[25] GenomicRanges_1.36.1        GenomeInfoDb_1.20.0        
[27] IRanges_2.18.3              S4Vectors_0.22.1           
[29] BiocGenerics_0.30.0         moments_0.14               
[31] emdbook_1.3.11              MASS_7.3-51.5              

loaded via a namespace (and not attached):
  [1] minqa_1.2.4            colorspace_1.4-1       ggsignif_0.6.0        
  [4] ellipsis_0.3.0         htmlTable_1.13.3       XVector_0.24.0        
  [7] base64enc_0.1-3        rstudioapi_0.11        MatrixModels_0.4-1    
 [10] bit64_0.9-7            AnnotationDbi_1.46.1   mvtnorm_1.0-12        
 [13] codetools_0.2-16       splines_3.6.2          pscl_1.5.5            
 [16] geneplotter_1.62.0     knitr_1.28             jsonlite_1.6.1        
 [19] Formula_1.2-3          nloptr_1.2.1           annotate_1.62.0       
 [22] kernlab_0.9-29         cluster_2.1.0          png_0.1-7             
 [25] compiler_3.6.2         backports_1.1.5        assertthat_0.2.1      
 [28] prettyunits_1.1.1      quantreg_5.55          acepack_1.4.1         
 [31] htmltools_0.4.0        tools_3.6.2            coda_0.19-3           
 [34] gtable_0.3.0           glue_1.3.1             GenomeInfoDbData_1.2.1
 [37] reshape2_1.4.3         dplyr_0.8.4            Rcpp_1.0.3            
 [40] bbmle_1.0.23.1         vctrs_0.3.0            ape_5.3               
 [43] nlme_3.1-144           xfun_0.12              stringr_1.4.0         
 [46] CompQuadForm_1.4.3     lifecycle_0.2.0        GUniFrac_1.1          
 [49] XML_3.99-0.3           PearsonDS_1.1          zlibbioc_1.30.0       
 [52] scales_1.1.0           hms_0.5.3              SparseM_1.78          
 [55] RColorBrewer_1.1-2     memoise_1.1.0          gridExtra_2.3         
 [58] segmented_1.2-0        bdsmatrix_1.3-4        rpart_4.1-15          
 [61] latticeExtra_0.6-29    stringi_1.4.5          RSQLite_2.2.0         
 [64] genefilter_1.66.0      blme_1.0-4             checkmate_2.0.0       
 [67] permute_0.9-5          boot_1.3-24            rlang_0.4.6           
 [70] pkgconfig_2.0.3        bitops_1.0-6           lattice_0.20-38       
 [73] purrr_0.3.3            htmlwidgets_1.5.1      bit_1.1-15.2          
 [76] tidyselect_1.0.0       plyr_1.8.5             R6_2.4.1              
 [79] Hmisc_4.4-0            DBI_1.1.0              withr_2.1.2           
 [82] pillar_1.4.3           foreign_0.8-75         mgcv_1.8-31           
 [85] mixtools_1.2.0         survival_3.1-8         abind_1.4-5           
 [88] RCurl_1.98-1.1         nnet_7.3-12            tibble_3.0.1          
 [91] crayon_1.3.4           progress_1.2.2         jpeg_0.1-8.1          
 [94] locfit_1.5-9.4         grid_3.6.2             blob_1.2.1            
 [97] vegan_2.5-6            digest_0.6.23          xtable_1.8-4          
[100] numDeriv_2016.8-1.1    munsell_0.5.0         
> 
> mem_used()
1.23 GB
> gc()
            used  (Mb) gc trigger   (Mb) limit (Mb)  max used   (Mb)
Ncells   7222828 385.8   12437792  664.3         NA  12437792  664.3
Vcells 102967691 785.6  369073708 2815.9      32768 576677668 4399.8
> 
> q(save = "no")
> proc.time()
     user    system   elapsed 
48028.330  2938.319  9374.713 
